<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>algorithm on Crispy bLog</title>
    <link>https://heozeop.github.io/categories/algorithm/</link>
    <description>Recent content in algorithm on Crispy bLog</description>
    <image>
      <url>https://heozeop.github.io/static/%ED%94%84%EB%A1%9C%ED%95%84%20%EC%9D%B4%EB%AF%B8%EC%A7%80.jpeg</url>
      <link>https://heozeop.github.io/static/%ED%94%84%EB%A1%9C%ED%95%84%20%EC%9D%B4%EB%AF%B8%EC%A7%80.jpeg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 13 Oct 2023 19:45:06 +0900</lastBuildDate><atom:link href="https://heozeop.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Algorithm Boj 15686</title>
      <link>https://heozeop.github.io/post/algorithm-boj-15686/</link>
      <pubDate>Fri, 13 Oct 2023 19:45:06 +0900</pubDate>
      
      <guid>https://heozeop.github.io/post/algorithm-boj-15686/</guid>
      <description>핵심 아이디어 NM짜리 이차원 배열을 이용해 최소 치킨 거리를 구한다. 백트랙을 이용해 M개 집 치킨거리를 구한다. 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 n, m = list(map(int, input().split())) city = [] for _ in range(n): city.</description>
    </item>
    
    <item>
      <title>Boj 15684</title>
      <link>https://heozeop.github.io/post/algorithm-boj-15684/</link>
      <pubDate>Sat, 07 Oct 2023 08:26:40 +0900</pubDate>
      
      <guid>https://heozeop.github.io/post/algorithm-boj-15684/</guid>
      <description>생각하기 핵심 로직 브루트포스 i -&amp;gt; i 로 가는지 점검한다. 짝수개여야 가능할 것 같다. 후보군을 리스트로 만든다. 후보군을 백트랙으로 돌면서 3개까지 돈다. 1-3반복한다. 핵심 조건 3보다 크면 -1 불가하면 -1 사고하지 못한점 짝수개여야 가능하다는 것은 필요 조건은 될 수 있어도 충분 조건이 아니다. 다음에 다시풀 문제 핵심 로직 탐지 탐지 하는 방법 내리가면서 시작점과 동일한 끝점인지 확인하기 내리 갈때는 양방향 확인하기 탐색 탐지 nh에 대해서 백트래킹 n^n*h^2 =&amp;gt; 90000으로 ㄱㅊ &amp;lt;- 틀림?</description>
    </item>
    
    <item>
      <title>Boj 14888</title>
      <link>https://heozeop.github.io/post/algorithm-boj-14888/</link>
      <pubDate>Fri, 06 Oct 2023 19:53:38 +0900</pubDate>
      
      <guid>https://heozeop.github.io/post/algorithm-boj-14888/</guid>
      <description>주요 로직 계속 계산하면서 큰값과 작은 값으로 비교한다. 전체 다 돌아야 하며, O(4n)이다. -10억 ~ 10억이므로 int 범위에서 된다. 예상하지 못한 것 음수가 나오는 경우, 나눗셈 연산을 할때 몫을 잘 구해야한다. 음수가 -10억까지 되는데 범위를 잘못 찍었다. code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 n = int(input()) nums = list(map(int, input().</description>
    </item>
    
    <item>
      <title>Boj 2661</title>
      <link>https://heozeop.github.io/post/algorithm-boj-2661/</link>
      <pubDate>Thu, 05 Oct 2023 18:31:38 +0900</pubDate>
      
      <guid>https://heozeop.github.io/post/algorithm-boj-2661/</guid>
      <description>주요 로직을 생각해 보자. 끝에 하나 붙을때 마다 점검해준다. 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 n = int(input()) s=[] def isBadSequence(addStr): temp = &amp;#34;&amp;#34;.join(s) + addStr for i in range(1, len(temp) // 2 + 1): if temp[-2 * i : -1 * i] == temp[-1 * i :]: return True return False def dfs(): global s if len(s) == n: print(&amp;#34;&amp;#34;.</description>
    </item>
    
    <item>
      <title>[알고리즘] Algorithm Boj 1107</title>
      <link>https://heozeop.github.io/post/algorithm-boj-1107/</link>
      <pubDate>Fri, 26 May 2023 05:12:05 +0900</pubDate>
      
      <guid>https://heozeop.github.io/post/algorithm-boj-1107/</guid>
      <description>TL;DR
GOLD4 문제 왜틀리지 시전 틀린 케이스를 찾아버리고야 말테다 그렇구나. 정확한 사고로 풀어야 겠다 오늘의 문제 뭔일인가. 논리적인 접근 위 문제는 특정한 값 위나 아래로 접근하며 가장 빠르게 도달하는 경우의 수를 구하는 문제입니다. 이러한 특성에 근거해, 목표로 하는 값의 2배로 접근시 충분히 원하는 결과를 얻을 것이라고 생각했습니다.
2번째 제출 까지는 말이죠
틀린답 using namespace std; vector&amp;lt;int&amp;gt; allowed; int targetChannel; int visited[1000001]; int m; int count(int); // 특정 지점으로 가는데까지 버튼 누르는 수 계산 void findCombinations(int, vector&amp;lt;int&amp;gt;&amp;amp;); // 1~제한까지 숫자 조합 생성 void input(); void solve(); int main(void) { input(); solve(); return 0; } void input() { cin &amp;gt;&amp;gt; targetChannel &amp;gt;&amp;gt; m; int temp; set&amp;lt;int&amp;gt; blocked; for(int i = 0; i &amp;lt; m; ++i) { cin &amp;gt;&amp;gt; temp; blocked.</description>
    </item>
    
  </channel>
</rss>
