<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>algorithm on Crispy bLog</title>
    <link>https://heozeop.github.io/categories/algorithm/</link>
    <description>Recent content in algorithm on Crispy bLog</description>
    <image>
      <url>https://heozeop.github.io/static/%ED%94%84%EB%A1%9C%ED%95%84%20%EC%9D%B4%EB%AF%B8%EC%A7%80.jpeg</url>
      <link>https://heozeop.github.io/static/%ED%94%84%EB%A1%9C%ED%95%84%20%EC%9D%B4%EB%AF%B8%EC%A7%80.jpeg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 06 Oct 2023 19:53:38 +0900</lastBuildDate><atom:link href="https://heozeop.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Boj 14888</title>
      <link>https://heozeop.github.io/post/algorithm-boj-14888/</link>
      <pubDate>Fri, 06 Oct 2023 19:53:38 +0900</pubDate>
      
      <guid>https://heozeop.github.io/post/algorithm-boj-14888/</guid>
      <description>주요 로직 계속 계산하면서 큰값과 작은 값으로 비교한다. 전체 다 돌아야 하며, O(4n)이다. -10억 ~ 10억이므로 int 범위에서 된다. 예상하지 못한 것 음수가 나오는 경우, 나눗셈 연산을 할때 몫을 잘 구해야한다. 음수가 -10억까지 되는데 범위를 잘못 찍었다. code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 n = int(input()) nums = list(map(int, input().</description>
    </item>
    
    <item>
      <title>Boj 2661</title>
      <link>https://heozeop.github.io/post/algorithm-boj-2661/</link>
      <pubDate>Thu, 05 Oct 2023 18:31:38 +0900</pubDate>
      
      <guid>https://heozeop.github.io/post/algorithm-boj-2661/</guid>
      <description>주요 로직을 생각해 보자. 끝에 하나 붙을때 마다 점검해준다. 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 n = int(input()) s=[] def isBadSequence(addStr): temp = &amp;#34;&amp;#34;.join(s) + addStr for i in range(1, len(temp) // 2 + 1): if temp[-2 * i : -1 * i] == temp[-1 * i :]: return True return False def dfs(): global s if len(s) == n: print(&amp;#34;&amp;#34;.</description>
    </item>
    
    <item>
      <title>[알고리즘] Algorithm Boj 1107</title>
      <link>https://heozeop.github.io/post/algorithm-boj-1107/</link>
      <pubDate>Fri, 26 May 2023 05:12:05 +0900</pubDate>
      
      <guid>https://heozeop.github.io/post/algorithm-boj-1107/</guid>
      <description>TL;DR
GOLD4 문제 왜틀리지 시전 틀린 케이스를 찾아버리고야 말테다 그렇구나. 정확한 사고로 풀어야 겠다 오늘의 문제 뭔일인가. 논리적인 접근 위 문제는 특정한 값 위나 아래로 접근하며 가장 빠르게 도달하는 경우의 수를 구하는 문제입니다. 이러한 특성에 근거해, 목표로 하는 값의 2배로 접근시 충분히 원하는 결과를 얻을 것이라고 생각했습니다.
2번째 제출 까지는 말이죠
틀린답 using namespace std; vector&amp;lt;int&amp;gt; allowed; int targetChannel; int visited[1000001]; int m; int count(int); // 특정 지점으로 가는데까지 버튼 누르는 수 계산 void findCombinations(int, vector&amp;lt;int&amp;gt;&amp;amp;); // 1~제한까지 숫자 조합 생성 void input(); void solve(); int main(void) { input(); solve(); return 0; } void input() { cin &amp;gt;&amp;gt; targetChannel &amp;gt;&amp;gt; m; int temp; set&amp;lt;int&amp;gt; blocked; for(int i = 0; i &amp;lt; m; ++i) { cin &amp;gt;&amp;gt; temp; blocked.</description>
    </item>
    
  </channel>
</rss>
