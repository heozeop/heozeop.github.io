<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algorithm Boj 1107 | Crispy bLog</title><meta name=keywords content="1107,bruteforce"><meta name=description content="TL;DR
GOLD4 문제 왜틀리지 시전 틀린 케이스를 찾아버리고야 말테다 그렇구나. 정확한 사고로 풀어야 겠다 오늘의 문제 뭔일인가. 논리적인 접근 위 문제는 특정한 값 위나 아래로 접근하며 가장 빠르게 도달하는 경우의 수를 구하는 문제입니다. 이러한 특성에 근거해, 목표로 하는 값의 2배로 접근시 충분히 원하는 결과를 얻을 것이라고 생각했습니다.
2번째 제출 까지는 말이죠
틀린답 using namespace std; vector<int> allowed; int targetChannel; int visited[1000001]; int m; int count(int); // 특정 지점으로 가는데까지 버튼 누르는 수 계산 void findCombinations(int, vector<int>&); // 1~제한까지 숫자 조합 생성 void input(); void solve(); int main(void) { input(); solve(); return 0; } void input() { cin >> targetChannel >> m; int temp; set<int> blocked; for(int i = 0; i < m; ++i) { cin >> temp; blocked."><meta name=author content="Crispy"><link rel=canonical href=https://heozeop.github.io/post/algorithm-boj-1107/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://heozeop.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heozeop.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heozeop.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://heozeop.github.io/apple-touch-icon.png><link rel=mask-icon href=https://heozeop.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Algorithm Boj 1107"><meta property="og:description" content="TL;DR
GOLD4 문제 왜틀리지 시전 틀린 케이스를 찾아버리고야 말테다 그렇구나. 정확한 사고로 풀어야 겠다 오늘의 문제 뭔일인가. 논리적인 접근 위 문제는 특정한 값 위나 아래로 접근하며 가장 빠르게 도달하는 경우의 수를 구하는 문제입니다. 이러한 특성에 근거해, 목표로 하는 값의 2배로 접근시 충분히 원하는 결과를 얻을 것이라고 생각했습니다.
2번째 제출 까지는 말이죠
틀린답 using namespace std; vector<int> allowed; int targetChannel; int visited[1000001]; int m; int count(int); // 특정 지점으로 가는데까지 버튼 누르는 수 계산 void findCombinations(int, vector<int>&); // 1~제한까지 숫자 조합 생성 void input(); void solve(); int main(void) { input(); solve(); return 0; } void input() { cin >> targetChannel >> m; int temp; set<int> blocked; for(int i = 0; i < m; ++i) { cin >> temp; blocked."><meta property="og:type" content="article"><meta property="og:url" content="https://heozeop.github.io/post/algorithm-boj-1107/"><meta property="og:image" content="https://heozeop.github.io/static/%ED%94%84%EB%A1%9C%ED%95%84%20%EC%9D%B4%EB%AF%B8%EC%A7%80.jpeg"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-05-26T05:12:05+09:00"><meta property="article:modified_time" content="2023-05-26T05:12:05+09:00"><meta property="og:site_name" content="Crispy bLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://heozeop.github.io/static/%ED%94%84%EB%A1%9C%ED%95%84%20%EC%9D%B4%EB%AF%B8%EC%A7%80.jpeg"><meta name=twitter:title content="Algorithm Boj 1107"><meta name=twitter:description content="TL;DR
GOLD4 문제 왜틀리지 시전 틀린 케이스를 찾아버리고야 말테다 그렇구나. 정확한 사고로 풀어야 겠다 오늘의 문제 뭔일인가. 논리적인 접근 위 문제는 특정한 값 위나 아래로 접근하며 가장 빠르게 도달하는 경우의 수를 구하는 문제입니다. 이러한 특성에 근거해, 목표로 하는 값의 2배로 접근시 충분히 원하는 결과를 얻을 것이라고 생각했습니다.
2번째 제출 까지는 말이죠
틀린답 using namespace std; vector<int> allowed; int targetChannel; int visited[1000001]; int m; int count(int); // 특정 지점으로 가는데까지 버튼 누르는 수 계산 void findCombinations(int, vector<int>&); // 1~제한까지 숫자 조합 생성 void input(); void solve(); int main(void) { input(); solve(); return 0; } void input() { cin >> targetChannel >> m; int temp; set<int> blocked; for(int i = 0; i < m; ++i) { cin >> temp; blocked."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heozeop.github.io/post/"},{"@type":"ListItem","position":2,"name":"Algorithm Boj 1107","item":"https://heozeop.github.io/post/algorithm-boj-1107/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Algorithm Boj 1107","name":"Algorithm Boj 1107","description":"TL;DR\nGOLD4 문제 왜틀리지 시전 틀린 케이스를 찾아버리고야 말테다 그렇구나. 정확한 사고로 풀어야 겠다 오늘의 문제 뭔일인가. 논리적인 접근 위 문제는 특정한 값 위나 아래로 접근하며 가장 빠르게 도달하는 경우의 수를 구하는 문제입니다. 이러한 특성에 근거해, 목표로 하는 값의 2배로 접근시 충분히 원하는 결과를 얻을 것이라고 생각했습니다.\n2번째 제출 까지는 말이죠\n틀린답 using namespace std; vector\u0026lt;int\u0026gt; allowed; int targetChannel; int visited[1000001]; int m; int count(int); // 특정 지점으로 가는데까지 버튼 누르는 수 계산 void findCombinations(int, vector\u0026lt;int\u0026gt;\u0026amp;); // 1~제한까지 숫자 조합 생성 void input(); void solve(); int main(void) { input(); solve(); return 0; } void input() { cin \u0026gt;\u0026gt; targetChannel \u0026gt;\u0026gt; m; int temp; set\u0026lt;int\u0026gt; blocked; for(int i = 0; i \u0026lt; m; ++i) { cin \u0026gt;\u0026gt; temp; blocked.","keywords":["1107","bruteforce"],"articleBody":" TL;DR\nGOLD4 문제 왜틀리지 시전 틀린 케이스를 찾아버리고야 말테다 그렇구나. 정확한 사고로 풀어야 겠다 오늘의 문제 뭔일인가. 논리적인 접근 위 문제는 특정한 값 위나 아래로 접근하며 가장 빠르게 도달하는 경우의 수를 구하는 문제입니다. 이러한 특성에 근거해, 목표로 하는 값의 2배로 접근시 충분히 원하는 결과를 얻을 것이라고 생각했습니다.\n2번째 제출 까지는 말이죠\n틀린답 using namespace std; vector allowed; int targetChannel; int visited[1000001]; int m; int count(int); // 특정 지점으로 가는데까지 버튼 누르는 수 계산 void findCombinations(int, vector\u0026); // 1~제한까지 숫자 조합 생성 void input(); void solve(); int main(void) { input(); solve(); return 0; } void input() { cin \u003e\u003e targetChannel \u003e\u003e m; int temp; set blocked; for(int i = 0; i \u003c m; ++i) { cin \u003e\u003e temp; blocked.insert(temp); } for(int i = 0; i \u003c 10; ++i) { if(blocked.find(i) != blocked.end()) { continue; } allowed.push_back(i); } return; } void solve() { if(m == 10) { cout \u003c\u003c abs(targetChannel - 100); return; } vector arr; findCombinations(0, arr); sort(arr.begin(), arr.end()); int localLow = INT_MAX; for(int i = 0; i \u003c arr.size(); ++i) { localLow = min(count(arr[i]), localLow); } cout \u003c\u003c min(localLow, abs(targetChannel - 100)); return; } void findCombinations(int n, vector\u0026 arr) { if(n * 10 \u003e= targetChannel * 10) { // 여기가 틀림 return; } if (visited[n]) { return; } visited[n] = 1; int nn; for(int i = 0; i \u003c allowed.size(); ++i) { nn = n * 10 + allowed[i]; if(nn \u003c= targetChannel * 10) { // 여기가 틀림 arr.push_back(nn); findLowerBound(nn, arr); } } return; } int count(int on) { return abs(targetChannel - on) + to_string(on).length(); } 답을 찾아보았다. 하도 안풀려서 답을 보니 그냥 100만으로 제한을 풀고 돌리더군요. 애석하게도… 답이 되었답니다.\n저는 이해할 수 없었습니다. 그래서 테스트 케이스를 찾기 시작했습니다. 열심히 돌려 888888에서는 되고, 888887에서는 실패를 했습니다. 아하! 모먼트 였습니다.\npage가 2개지요! 고려할 경우의 수 이 문제에서 고려해야 하는 문제는 3가지 입니다. 이중 큰값에서 내려올때 저 멀리서 뛰어오는 값이 있을 것입니다. 이 값은 100만 보다는 작을 것입니다. 즉 어떠한 가정을 세우기 보다 100만이라는 숫자에 집중할 필요가 있었다는 것입니다.\n최초 시작과의 거리 큰값에서 내려올때 거리 작은 값에서 내려올때 거리 앞으로는 추정이 아닌 정확한 근거에 기반해서 문제에 접근합니다. 논리 구조가 빈약하면 선택을 보류합니다. ","wordCount":"350","inLanguage":"en","datePublished":"2023-05-26T05:12:05+09:00","dateModified":"2023-05-26T05:12:05+09:00","author":{"@type":"Person","name":"Crispy"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://heozeop.github.io/post/algorithm-boj-1107/"},"publisher":{"@type":"Organization","name":"Crispy bLog","logo":{"@type":"ImageObject","url":"https://heozeop.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heozeop.github.io/ accesskey=h title="Crispy bLog (Alt + H)">Crispy bLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://heozeop.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://heozeop.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://heozeop.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://heozeop.github.io/post/>Posts</a></div><h1 class=post-title>Algorithm Boj 1107</h1><div class=post-meta><span title='2023-05-26 05:12:05 +0900 KST'>May 26, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;350 words&nbsp;·&nbsp;Crispy&nbsp;|&nbsp;<a href=https://github.com/heozeop/I-want-to-know-why/content/post/algorithm-boj-1107.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><blockquote><p>TL;DR</p></blockquote><ol><li>GOLD4 문제 왜틀리지 시전</li><li>틀린 케이스를 찾아버리고야 말테다</li><li>그렇구나. 정확한 사고로 풀어야 겠다</li></ol><h1 id=오늘의-문제>오늘의 문제<a hidden class=anchor aria-hidden=true href=#오늘의-문제>#</a></h1><p><img loading=lazy src=https://github.com/heozeop/I-want-to-know-why/assets/29042329/0c4ab650-c601-4802-916f-ecdbe1818f3b alt=boj-1107></p><h2 id=뭔일인가>뭔일인가.<a hidden class=anchor aria-hidden=true href=#뭔일인가>#</a></h2><h3 id=논리적인-접근>논리적인 접근<a hidden class=anchor aria-hidden=true href=#논리적인-접근>#</a></h3><p>위 문제는 특정한 값 위나 아래로 접근하며 가장 빠르게 도달하는 경우의 수를 구하는 문제입니다.
이러한 특성에 근거해, 목표로 하는 값의 2배로 접근시 충분히 원하는 결과를 얻을 것이라고 생각했습니다.</p><p><em>2번째 제출 까지는 말이죠</em></p><ul><li>틀린답</li></ul><pre><code>using namespace std;

vector&lt;int&gt; allowed;
int targetChannel;
int visited[1000001];
int m;
int count(int); // 특정 지점으로 가는데까지 버튼 누르는 수 계산
void findCombinations(int, vector&lt;int&gt;&amp;); // 1~제한까지 숫자 조합 생성

void input();
void solve();

int main(void) {
  input();
  solve();
  return 0;
}

void input() {
  cin &gt;&gt; targetChannel &gt;&gt; m;

  int temp;
  set&lt;int&gt; blocked;
  for(int i = 0; i &lt; m; ++i) {
    cin &gt;&gt; temp;
    blocked.insert(temp);
  }

  for(int i = 0; i &lt; 10; ++i) {
    if(blocked.find(i) != blocked.end()) {
      continue;
    }

    allowed.push_back(i); 
  }

  return;
}

void solve() {
  if(m == 10) {
    cout &lt;&lt; abs(targetChannel - 100);
    return;
  }

  vector&lt;int&gt; arr;

  findCombinations(0, arr);

  sort(arr.begin(), arr.end());

  int localLow = INT_MAX;
  for(int i = 0; i &lt; arr.size(); ++i) {
    localLow = min(count(arr[i]), localLow);
  }

  cout &lt;&lt; min(localLow, abs(targetChannel - 100));

  return;
}

void findCombinations(int n, vector&lt;int&gt;&amp; arr) {
  if(n * 10 &gt;= targetChannel * 10) { // 여기가 틀림
    return;
  }

  if (visited[n]) {
    return;
  }

  visited[n] = 1;
  int nn;
  for(int i = 0; i &lt; allowed.size(); ++i) {
    nn = n * 10 + allowed[i];

    if(nn &lt;= targetChannel * 10) { // 여기가 틀림
      arr.push_back(nn);
      findLowerBound(nn, arr);
    }
  }

  return;
}

int count(int on) {
  return abs(targetChannel - on) + to_string(on).length();
}
</code></pre><h3 id=답을-찾아보았다>답을 찾아보았다.<a hidden class=anchor aria-hidden=true href=#답을-찾아보았다>#</a></h3><p>하도 안풀려서 답을 보니 그냥 100만으로 제한을 풀고 돌리더군요.
애석하게도&mldr; 답이 되었답니다.</p><p>저는 이해할 수 없었습니다. 그래서 테스트 케이스를 찾기 시작했습니다.
열심히 돌려 888888에서는 되고, 888887에서는 실패를 했습니다.
아하! 모먼트 였습니다.</p><ul><li>page가 2개지요!
<img loading=lazy src=https://github.com/heozeop/I-want-to-know-why/assets/29042329/ae7e2b65-9d13-430d-b7cf-da03d5bba3a5 alt="boj 문제 제출 기록"></li></ul><h3 id=고려할-경우의-수>고려할 경우의 수<a hidden class=anchor aria-hidden=true href=#고려할-경우의-수>#</a></h3><p>이 문제에서 고려해야 하는 문제는 3가지 입니다.
이중 큰값에서 내려올때 저 멀리서 뛰어오는 값이 있을 것입니다. 이 값은 100만 보다는 작을 것입니다.
즉 어떠한 가정을 세우기 보다 100만이라는 숫자에 집중할 필요가 있었다는 것입니다.</p><ol><li>최초 시작과의 거리</li><li>큰값에서 내려올때 거리</li><li>작은 값에서 내려올때 거리</li></ol><h2 id=앞으로는>앞으로는<a hidden class=anchor aria-hidden=true href=#앞으로는>#</a></h2><ol><li>추정이 아닌 정확한 근거에 기반해서 문제에 접근합니다.</li><li>논리 구조가 빈약하면 선택을 보류합니다.</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://heozeop.github.io/tags/1107/>1107</a></li><li><a href=https://heozeop.github.io/tags/bruteforce/>bruteforce</a></li></ul><nav class=paginav><a class=next href=https://heozeop.github.io/post/book-memories-dreams-reflections/><span class=title>Next »</span><br><span>[책] '기억, 꿈, 사상'에 대한 감상</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Algorithm Boj 1107 on twitter" href="https://twitter.com/intent/tweet/?text=Algorithm%20Boj%201107&url=https%3a%2f%2fheozeop.github.io%2fpost%2falgorithm-boj-1107%2f&hashtags=1107%2cbruteforce"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Algorithm Boj 1107 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fheozeop.github.io%2fpost%2falgorithm-boj-1107%2f&title=Algorithm%20Boj%201107&summary=Algorithm%20Boj%201107&source=https%3a%2f%2fheozeop.github.io%2fpost%2falgorithm-boj-1107%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Algorithm Boj 1107 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fheozeop.github.io%2fpost%2falgorithm-boj-1107%2f&title=Algorithm%20Boj%201107"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Algorithm Boj 1107 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fheozeop.github.io%2fpost%2falgorithm-boj-1107%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Algorithm Boj 1107 on whatsapp" href="https://api.whatsapp.com/send?text=Algorithm%20Boj%201107%20-%20https%3a%2f%2fheozeop.github.io%2fpost%2falgorithm-boj-1107%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Algorithm Boj 1107 on telegram" href="https://telegram.me/share/url?text=Algorithm%20Boj%201107&url=https%3a%2f%2fheozeop.github.io%2fpost%2falgorithm-boj-1107%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=heozeop/heozeop.github.io issue-term=title label=Comment theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://heozeop.github.io/>Crispy bLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>