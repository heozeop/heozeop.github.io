<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>좋은 코드와 나쁜 코드 | Crispy bLog</title><meta name=keywords content="좋은 코드,나쁜 코드"><meta name=description content="품질의 정의와 좋다 나쁘다를 생각하기"><meta name=author content="Crispy"><link rel=canonical href=https://heozeop.github.io/post/book-good-code-bad-code/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://heozeop.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heozeop.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heozeop.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://heozeop.github.io/apple-touch-icon.png><link rel=mask-icon href=https://heozeop.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="좋은 코드와 나쁜 코드"><meta property="og:description" content="품질의 정의와 좋다 나쁘다를 생각하기"><meta property="og:type" content="article"><meta property="og:url" content="https://heozeop.github.io/post/book-good-code-bad-code/"><meta property="og:image" content="https://heozeop.github.io/static/%ED%94%84%EB%A1%9C%ED%95%84%20%EC%9D%B4%EB%AF%B8%EC%A7%80.jpeg"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-06-20T16:10:35+09:00"><meta property="article:modified_time" content="2023-06-20T16:10:35+09:00"><meta property="og:site_name" content="Crispy bLog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://heozeop.github.io/static/%ED%94%84%EB%A1%9C%ED%95%84%20%EC%9D%B4%EB%AF%B8%EC%A7%80.jpeg"><meta name=twitter:title content="좋은 코드와 나쁜 코드"><meta name=twitter:description content="품질의 정의와 좋다 나쁘다를 생각하기"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heozeop.github.io/post/"},{"@type":"ListItem","position":2,"name":"좋은 코드와 나쁜 코드","item":"https://heozeop.github.io/post/book-good-code-bad-code/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"좋은 코드와 나쁜 코드","name":"좋은 코드와 나쁜 코드","description":"품질의 정의와 좋다 나쁘다를 생각하기","keywords":["좋은 코드","나쁜 코드"],"articleBody":"TL;DR 코드 품질은 안전하고, 고장나지 않으며, 생각한 대로 잘 동작하는데 목표를 둡니다. 위 4가지 목표를 달성하기 위해서는 적절한 추상화가 중요합니다. 문제를 적절히 예측하며 에러와 응답을 다뤄야 합니다. 시작 추천 받은 책 이 책은 동료분이 읽으신다고 알려주신 책입니다. 모호했던 코드 품질의 개념이라던지, 좋은 코드를 짜는 방법에 대한 논의를 잘 정리한 것 같다는 느낌을 받았습니다. 이에 약 1달이라는 기간동안 출퇴근 시간에 읽으며 공감했던 내용을 정리해 봅니다. 스타트업 3년차의 눈으로 바라본 좋은 코드에 대한 의견은 마지막에 정리했으니, 제 의견만 궁금하시다면 끝 쪽만 읽으시면 됩니다.\n코드 품질의 목표 코드 품질 이 책에서 코드 품질은 위 4가지 기준으로 평가됩니다.\n모호한 개념이다 보니 처음엔 정의 조차 모호하다는 느낌을 받았습니다. 하지만 책의 상세한 설명에서 작가의 의도를 조금씩 알게되었고, 지금은 가장 어울리는 기준이라고 생각하게 되었답니다. 궁금하시다면 책을 한번 빌려서 보시는 것도 추천드립니다.\n안전한 고장나지 않는 잘 동작하는 예측 대로 동작하는 좋은 코드의 조건 책에서는 위 4가지 기준의 달성을 확인하기 위한 6가지 조건을 제시합니다. 아래 항목들에 대해 왜보다는 어떻게에 대한 내용을 하나씩 풀어가서 의도는 명확하진 않습니다. 단, 충분히 잘 설명을 해주어 어떤 조건이 어떤 기준을 평가하는데 사용되는지 미루어 짐작할 수 있게 합니다.\n제가 가장 감명깊게 본 항목은 2. 예측 가능성과 3. 모듈화를 입니다.\n읽기 쉬워야 한다. 예측 가능해야 한다. 오용하기 어렵다. 모듈화 되어 있다. 재사용/일반화가 가능하다. 테스트가 용이하고, 제대로 했다. 감명 깊게 읽은 예측 가능성 예측 가능하다는 어떤 정의를 따라갈까요?\n책에서는 특정 코드의 세부 동작과 응답이 의도한대로 동작하는 정도를 예측 가능성이라고 풀어갑니다.\n세부 동작의 경우 우리가 의도한 동작을 하는지, 의도하지 않은 동작이 대비되어 있는지를 논합니다. 이는 우리가 a + b를 계산할때 a가 숫자가 아닌 경우, 둘다 숫자인 경우 등을 다 대비했는지에 대한 관점입니다. 한마디로 예외 처리를 얼마나 잘했는가에 대한 의견이라고 봤습니다.\n한편으로 응답은 얼만큼 응답이 우리의 의도를 잘 나타내는가에 대한 내용을 다룹니다. 특히 Null값과 관련해 Null 안전성을 지원하는 언어와 아닌 언어를 나눠 올바른 응답에 대해 고민하게 합니다.\nNull값 Null값은 흔히 비어있는 값이라는 의도로 사용됩니다. 이 의도 속에는 에러 상황이 포함되어 있어 Null값의 의미가 중복되는 어려움을 만나기도 합니다. 이 문제에 현명하게 접근하기 위해서는 사용하는 언어가 Null 안전성을 지원하는지 여부를 고려해야 합니다.\nNull 안전성 Null 안전성은 특정 객체가 Null이 될 수 있음을 컴파일러 단에서 가려주는지 여부를 말합니다. 흔히 Dart 나 Kotlin은 Null 안전성을 지원한다고 하고, JAVA, Javascript 등은 그렇지 않다고 합니다. Null 안전성을 지원할 경우, 의도적으로 Null값을 사용할 수 있습니다. Null인 경우를 사용처가 대비해야만 컴파일러가 코드를 컴파일을 해줍니다.\n응답 타입 Null 안전성을 지원하지 않는 경우, Optional 타입이나 응답 타입을 갖추는 것이 좋습니다. Optional 타입의 예시는 JAVA의 Optional객체가 있습니다. 응답 타입의 경우 Rust가 그 예시 언어입니다. 사용 사례로 빈 객체를 응답으로 쓸 때, 실제 조회 결과가 빈 객체인지 아니면 의도한 실패로 빈 객체가 넘어 갔는지 표현하는 경우가 있습니다.\n아래는 임시로 만들어 본 응답타입의 예입니다.\n1 2 3 4 5 interface IResponse\u003cT\u003e { success: boolean; data: T msg: null | string; } 모듈화 모듈화는 코드를 논리적인 단위로 나누는 행위 전반을 의미합니다.\n저는 보통 요구사항과 코드의 중복이라는 관점에서 모듈화를 하곤 합니다. 하지만 항상 선택은 섣부르고 재작업의 신호탄이 되었던 것 같습니다. 요구사항은 변화무쌍하고 중복이라고 생각했던 코드는 논리적으로 하는일이 다르기도 했습니다.\n책에서는 이런 제게 요구사항이 변할 수 있음을 인지하고 모듈화를 진행하라고 말합니다. 그 구체적인 방법으로 Composite 패턴의 사용을 제안합니다.\nComposite 패턴 Composite 패턴은 의존성 주입을 통해 의도한 동작을 실현시키는 패턴입니다. 의존성 주입은 특정 인터페이스를 구현하는 객체를 생성 시에 입력해 주는 것을 말합니다. 이 방법으로 런타임에 의존성을 주입받아 사용할 수 있고, 이덕에 다양한 활용이 가능합니다.\n이해를 돕기위해 간단한 예로 합체로봇을 들어보겠습니다. 어릴적 가지고 놀던 5개 로봇을 합체해 만드는 합체로봇을 떠올려 봅시다. 가끔 팔 두짝에 다른 작은 로봇을 붙여 새로운 능력을 가진 합체로봇을 만들기도 합니다. 이런 합체로봇이 바로 Composite 패턴을 이용했다고 볼 수 있습니다.\n장점과 단점 런타임에 원하는 동작을 수행하는 도구를 주입받아 사용할 수 있다는게 가장 큰 매력인 것 같습니다. 또한 상속을 사용하는 것 보다 쉽게 변경에 대응하기 편하다는 느낌을 받아왔습니다.\n다만 이 역시 좋은 설계가 우선되어야 해서 자칫 잘못된 요구사항 분석으로 작업량이 오히려 늘어날 수 있음을 인지해야 합니다. 팔만 분리하게 했는데 팔에 팔 관절도 분리하고 싶으면 또 그걸 나눠야 겠죠? 작업량이 배가됩니다.\n종합적으로 Composite 패턴은 좋은 코드를 짜는데 도움이 되는 패턴이라고 생각합니다.\n3년차 허수(?)의 관점으로 보는 좋은 품질의 코드는 머리 속으로 돌려볼 수 있는 코드 저는 동작을 상상할 수 있는 코드가 좋은 품질의 코드라고 생각합니다.\n그림 없이 머릿속으로 코드를 돌려보기 위해서는 코드의 역할들이 명확 해야합니다. 예측 가능하게 로직과 응답을 구성하고 잘 분류해 놓는다면 상상하기 더욱 쉬울 것입니다. 그 결과 오류의 탐색 및 기능의 추가가 더 원할해 질 가능성이 높아진다고 생각합니다. 그래서 상상할 수 있는 코드를 작성하고자 노력해야 합니다.\n좋은 코드 짜는 방법은 먼저 도식화하고 개발하기 좋은 구조 아래 좋은 코드가 생성됩니다.\n코드를 짜기 전 도식화를 통해 내가 만들 로직을 상상하기 쉽게 만드는 것은 좋은 코드를 짜는 방법 중 하나입니다. 이는 생각보다 쉽지 않은데, 빨리 결과를 내고 싶다는 조바심이 크기때문입니다. 이런 자신을 잘 다스려 상상을 그림으로 그려내면, 더 좋은 코드를 짤 수 있다고 생각합니다.\n탈고하기 탈고는 논리를 돌아보는 과정입니다.\n우리가 작성한 코드는 몇가지 의도를 가지고 나타냅니다. 하지만 위에서 서술했듯 구현에 매몰되다보면 의도를 정확히 해석해 내지 못하는 코드가 생성됩니다. 이런 상황은 좋은 품질의 코드를 생성하고자 하는 우리의 목적에 반하는 결과를 만듭니다. 그렇기 때문에 코드를 짜고 난 뒤, 목적을 잘 달성했는지 탈고하는 과정은 중요합니다. 쉽지 않지만, 그렇기에 했을 때 득이 많은 방법이라고 생각합니다.\n정리 지금까지 제가 책에서 공감했던, 관심있게 봤던 내용들과 좋은 코드에 대한 제 생각을 풀어보았습니다. 제가 잘못 파악한 내용이 있거나 잘못 작성한 내용이 있다면, 부담없이 댓글 부탁드려요!\n읽어 주셔서 감사합니다. 아래는 이 글의 키워드를 정리한 것입니다.\n키워드 정리 좋은 품질의 코드 읽기 쉽고, 예측가능하며, 잘 동작하고, 안전한 코드. 좋은 코드의 조건 읽기 쉽다 예측 가능하다. 오용하기 어렵다. 재사용/일반화가 가능하다. 테스트가 용이하고, 제대로 한다. 예측하기 쉬운 코드 세부동작을 예측하기 쉽게 하기 응답의 의도를 예측할 수 있게 하기 Null 안전성 모듈화 재사용 가능하게 하기 Composite패턴 쓰기 ","wordCount":"896","inLanguage":"en","datePublished":"2023-06-20T16:10:35+09:00","dateModified":"2023-06-20T16:10:35+09:00","author":{"@type":"Person","name":"Crispy"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://heozeop.github.io/post/book-good-code-bad-code/"},"publisher":{"@type":"Organization","name":"Crispy bLog","logo":{"@type":"ImageObject","url":"https://heozeop.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heozeop.github.io/ accesskey=h title="Crispy bLog (Alt + H)">Crispy bLog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://heozeop.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://heozeop.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://heozeop.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://heozeop.github.io/post/>Posts</a></div><h1 class=post-title>좋은 코드와 나쁜 코드</h1><div class=post-description>품질의 정의와 좋다 나쁘다를 생각하기</div><div class=post-meta><span title='2023-06-20 16:10:35 +0900 KST'>June 20, 2023</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;896 words&nbsp;·&nbsp;Crispy&nbsp;|&nbsp;<a href=https://github.com/heozeop/I-want-to-know-why/content/post/book-good-code-bad-code.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h1><ol><li>코드 품질은 안전하고, 고장나지 않으며, 생각한 대로 잘 동작하는데 목표를 둡니다.</li><li>위 4가지 목표를 달성하기 위해서는 적절한 추상화가 중요합니다.</li><li>문제를 적절히 예측하며 에러와 응답을 다뤄야 합니다.</li></ol><h1 id=시작>시작<a hidden class=anchor aria-hidden=true href=#시작>#</a></h1><h2 id=추천-받은-책>추천 받은 책<a hidden class=anchor aria-hidden=true href=#추천-받은-책>#</a></h2><p>이 책은 동료분이 읽으신다고 알려주신 책입니다. 모호했던 코드 품질의 개념이라던지, 좋은 코드를 짜는 방법에 대한 논의를 잘 정리한 것 같다는 느낌을 받았습니다.
이에 약 1달이라는 기간동안 출퇴근 시간에 읽으며 공감했던 내용을 정리해 봅니다.
스타트업 3년차의 눈으로 바라본 좋은 코드에 대한 의견은 마지막에 정리했으니, 제 의견만 궁금하시다면 끝 쪽만 읽으시면 됩니다.</p><h2 id=코드-품질의-목표>코드 품질의 목표<a hidden class=anchor aria-hidden=true href=#코드-품질의-목표>#</a></h2><h3 id=코드-품질>코드 품질<a hidden class=anchor aria-hidden=true href=#코드-품질>#</a></h3><p>이 책에서 코드 품질은 위 4가지 기준으로 평가됩니다.</p><p>모호한 개념이다 보니 처음엔 정의 조차 모호하다는 느낌을 받았습니다.
하지만 책의 상세한 설명에서 작가의 의도를 조금씩 알게되었고, 지금은 가장 어울리는 기준이라고 생각하게 되었답니다.
궁금하시다면 책을 한번 빌려서 보시는 것도 추천드립니다.</p><ol><li>안전한</li><li>고장나지 않는</li><li>잘 동작하는</li><li>예측 대로 동작하는</li></ol><h3 id=좋은-코드의-조건>좋은 코드의 조건<a hidden class=anchor aria-hidden=true href=#좋은-코드의-조건>#</a></h3><p>책에서는 위 4가지 기준의 달성을 확인하기 위한 6가지 조건을 제시합니다.
아래 항목들에 대해 <code>왜</code>보다는 <code>어떻게</code>에 대한 내용을 하나씩 풀어가서 의도는 명확하진 않습니다.
단, 충분히 잘 설명을 해주어 어떤 조건이 어떤 기준을 평가하는데 사용되는지 미루어 짐작할 수 있게 합니다.</p><p>제가 가장 감명깊게 본 항목은 <code>2. 예측 가능성</code>과 <code>3. 모듈화</code>를 입니다.</p><ol><li>읽기 쉬워야 한다.</li><li>예측 가능해야 한다.</li><li>오용하기 어렵다.</li><li>모듈화 되어 있다.</li><li>재사용/일반화가 가능하다.</li><li>테스트가 용이하고, 제대로 했다.</li></ol><h1 id=감명-깊게-읽은>감명 깊게 읽은<a hidden class=anchor aria-hidden=true href=#감명-깊게-읽은>#</a></h1><h2 id=예측-가능성>예측 가능성<a hidden class=anchor aria-hidden=true href=#예측-가능성>#</a></h2><p><code>예측 가능하다</code>는 어떤 정의를 따라갈까요?</p><p>책에서는 특정 코드의 세부 동작과 응답이 의도한대로 동작하는 정도를 예측 가능성이라고 풀어갑니다.</p><p>세부 동작의 경우 우리가 의도한 동작을 하는지, 의도하지 않은 동작이 대비되어 있는지를 논합니다.
이는 우리가 a + b를 계산할때 a가 숫자가 아닌 경우, 둘다 숫자인 경우 등을 다 대비했는지에 대한 관점입니다.
한마디로 예외 처리를 얼마나 잘했는가에 대한 의견이라고 봤습니다.</p><p>한편으로 응답은 얼만큼 응답이 우리의 의도를 잘 나타내는가에 대한 내용을 다룹니다.
특히 <code>Null</code>값과 관련해 <code>Null</code> 안전성을 지원하는 언어와 아닌 언어를 나눠 올바른 응답에 대해 고민하게 합니다.</p><h3 id=null값><code>Null</code>값<a hidden class=anchor aria-hidden=true href=#null값>#</a></h3><p><code>Null</code>값은 흔히 비어있는 값이라는 의도로 사용됩니다.
이 의도 속에는 에러 상황이 포함되어 있어 <code>Null</code>값의 의미가 중복되는 어려움을 만나기도 합니다.
이 문제에 현명하게 접근하기 위해서는 사용하는 언어가 <code>Null</code> 안전성을 지원하는지 여부를 고려해야 합니다.</p><h3 id=null-안전성><code>Null</code> 안전성<a hidden class=anchor aria-hidden=true href=#null-안전성>#</a></h3><p><code>Null</code> 안전성은 특정 객체가 <code>Null</code>이 될 수 있음을 컴파일러 단에서 가려주는지 여부를 말합니다.
흔히 Dart 나 Kotlin은 <code>Null</code> 안전성을 지원한다고 하고, JAVA, Javascript 등은 그렇지 않다고 합니다.
<code>Null</code> 안전성을 지원할 경우, 의도적으로 <code>Null</code>값을 사용할 수 있습니다.
<code>Null</code>인 경우를 사용처가 대비해야만 컴파일러가 코드를 컴파일을 해줍니다.</p><h3 id=응답-타입>응답 타입<a hidden class=anchor aria-hidden=true href=#응답-타입>#</a></h3><p><code>Null</code> 안전성을 지원하지 않는 경우, <code>Optional</code> 타입이나 응답 타입을 갖추는 것이 좋습니다.
<code>Optional</code> 타입의 예시는 JAVA의 Optional객체가 있습니다. 응답 타입의 경우 Rust가 그 예시 언어입니다.
사용 사례로 빈 객체를 응답으로 쓸 때, 실제 조회 결과가 빈 객체인지 아니면 의도한 실패로 빈 객체가 넘어 갔는지 표현하는 경우가 있습니다.</p><p>아래는 임시로 만들어 본 응답타입의 예입니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>interface</span> <span class=nx>IResponse</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>success</span>: <span class=kt>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>data</span>: <span class=kt>T</span>
</span></span><span class=line><span class=cl>  <span class=nx>msg</span>: <span class=kt>null</span> <span class=o>|</span> <span class=kt>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=모듈화>모듈화<a hidden class=anchor aria-hidden=true href=#모듈화>#</a></h2><p><code>모듈화</code>는 코드를 논리적인 단위로 나누는 행위 전반을 의미합니다.</p><p>저는 보통 요구사항과 코드의 중복이라는 관점에서 모듈화를 하곤 합니다.
하지만 항상 선택은 섣부르고 재작업의 신호탄이 되었던 것 같습니다.
요구사항은 변화무쌍하고 중복이라고 생각했던 코드는 논리적으로 하는일이 다르기도 했습니다.</p><p>책에서는 이런 제게 요구사항이 변할 수 있음을 인지하고 모듈화를 진행하라고 말합니다.
그 구체적인 방법으로 <code>Composite</code> 패턴의 사용을 제안합니다.</p><h3 id=composite-패턴><code>Composite</code> 패턴<a hidden class=anchor aria-hidden=true href=#composite-패턴>#</a></h3><p><code>Composite</code> 패턴은 의존성 주입을 통해 의도한 동작을 실현시키는 패턴입니다.
의존성 주입은 특정 인터페이스를 구현하는 객체를 생성 시에 입력해 주는 것을 말합니다.
이 방법으로 런타임에 의존성을 주입받아 사용할 수 있고, 이덕에 다양한 활용이 가능합니다.</p><p>이해를 돕기위해 간단한 예로 합체로봇을 들어보겠습니다.
어릴적 가지고 놀던 5개 로봇을 합체해 만드는 합체로봇을 떠올려 봅시다.
가끔 팔 두짝에 다른 작은 로봇을 붙여 새로운 능력을 가진 합체로봇을 만들기도 합니다.
이런 합체로봇이 바로 <code>Composite</code> 패턴을 이용했다고 볼 수 있습니다.</p><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><p>런타임에 원하는 동작을 수행하는 도구를 주입받아 사용할 수 있다는게 가장 큰 매력인 것 같습니다.
또한 상속을 사용하는 것 보다 쉽게 변경에 대응하기 편하다는 느낌을 받아왔습니다.</p><p>다만 이 역시 좋은 설계가 우선되어야 해서 자칫 잘못된 요구사항 분석으로 작업량이 오히려 늘어날 수 있음을 인지해야 합니다.
팔만 분리하게 했는데 팔에 팔 관절도 분리하고 싶으면 또 그걸 나눠야 겠죠?
작업량이 배가됩니다.</p><p>종합적으로 <code>Composite</code> 패턴은 좋은 코드를 짜는데 도움이 되는 패턴이라고 생각합니다.</p><h1 id=3년차-허수의-관점으로-보는>3년차 허수(?)의 관점으로 보는<a hidden class=anchor aria-hidden=true href=#3년차-허수의-관점으로-보는>#</a></h1><h2 id=좋은-품질의-코드는>좋은 품질의 코드는<a hidden class=anchor aria-hidden=true href=#좋은-품질의-코드는>#</a></h2><h3 id=머리-속으로-돌려볼-수-있는-코드>머리 속으로 돌려볼 수 있는 코드<a hidden class=anchor aria-hidden=true href=#머리-속으로-돌려볼-수-있는-코드>#</a></h3><p>저는 동작을 상상할 수 있는 코드가 좋은 품질의 코드라고 생각합니다.</p><p>그림 없이 머릿속으로 코드를 돌려보기 위해서는 코드의 역할들이 명확 해야합니다.
예측 가능하게 로직과 응답을 구성하고 잘 분류해 놓는다면 상상하기 더욱 쉬울 것입니다.
그 결과 오류의 탐색 및 기능의 추가가 더 원할해 질 가능성이 높아진다고 생각합니다.
그래서 상상할 수 있는 코드를 작성하고자 노력해야 합니다.</p><h2 id=좋은-코드-짜는-방법은>좋은 코드 짜는 방법은<a hidden class=anchor aria-hidden=true href=#좋은-코드-짜는-방법은>#</a></h2><h3 id=먼저-도식화하고-개발하기>먼저 도식화하고 개발하기<a hidden class=anchor aria-hidden=true href=#먼저-도식화하고-개발하기>#</a></h3><p>좋은 구조 아래 좋은 코드가 생성됩니다.</p><p>코드를 짜기 전 도식화를 통해 내가 만들 로직을 상상하기 쉽게 만드는 것은 좋은 코드를 짜는 방법 중 하나입니다.
이는 생각보다 쉽지 않은데, 빨리 결과를 내고 싶다는 조바심이 크기때문입니다.
이런 자신을 잘 다스려 상상을 그림으로 그려내면, 더 좋은 코드를 짤 수 있다고 생각합니다.</p><h3 id=탈고하기>탈고하기<a hidden class=anchor aria-hidden=true href=#탈고하기>#</a></h3><p>탈고는 논리를 돌아보는 과정입니다.</p><p>우리가 작성한 코드는 몇가지 의도를 가지고 나타냅니다.
하지만 위에서 서술했듯 구현에 매몰되다보면 의도를 정확히 해석해 내지 못하는 코드가 생성됩니다.
이런 상황은 좋은 품질의 코드를 생성하고자 하는 우리의 목적에 반하는 결과를 만듭니다.
그렇기 때문에 코드를 짜고 난 뒤, 목적을 잘 달성했는지 탈고하는 과정은 중요합니다.
쉽지 않지만, 그렇기에 했을 때 득이 많은 방법이라고 생각합니다.</p><h1 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h1><p>지금까지 제가 책에서 공감했던, 관심있게 봤던 내용들과 좋은 코드에 대한 제 생각을 풀어보았습니다.
제가 잘못 파악한 내용이 있거나 잘못 작성한 내용이 있다면, 부담없이 댓글 부탁드려요!</p><p>읽어 주셔서 감사합니다. 아래는 이 글의 키워드를 정리한 것입니다.</p><h3 id=키워드-정리>키워드 정리<a hidden class=anchor aria-hidden=true href=#키워드-정리>#</a></h3><ul><li>좋은 품질의 코드<ul><li>읽기 쉽고, 예측가능하며, 잘 동작하고, 안전한 코드.</li></ul></li><li>좋은 코드의 조건<ol><li>읽기 쉽다</li><li>예측 가능하다.</li><li>오용하기 어렵다.</li><li>재사용/일반화가 가능하다.</li><li>테스트가 용이하고, 제대로 한다.</li></ol></li><li>예측하기 쉬운 코드<ul><li>세부동작을 예측하기 쉽게 하기</li><li>응답의 의도를 예측할 수 있게 하기<ul><li><code>Null</code> 안전성</li></ul></li></ul></li><li>모듈화<ul><li>재사용 가능하게 하기</li><li><code>Composite</code>패턴 쓰기</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://heozeop.github.io/tags/opionion/>opionion</a></li></ul><nav class=paginav><a class=prev href=https://heozeop.github.io/post/nestjs-basic-auth-fastify/><span class=title>« Prev</span><br><span>[NestJS] 스웨거에 BasicAuth 더하기, feat fastify,GCP</span></a>
<a class=next href=https://heozeop.github.io/post/book-memories-dreams-reflections/><span class=title>Next »</span><br><span>[책] '기억, 꿈, 사상'에 대한 감상</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 코드와 나쁜 코드 on twitter" href="https://twitter.com/intent/tweet/?text=%ec%a2%8b%ec%9d%80%20%ec%bd%94%eb%93%9c%ec%99%80%20%eb%82%98%ec%81%9c%20%ec%bd%94%eb%93%9c&url=https%3a%2f%2fheozeop.github.io%2fpost%2fbook-good-code-bad-code%2f&hashtags=opionion"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 코드와 나쁜 코드 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fheozeop.github.io%2fpost%2fbook-good-code-bad-code%2f&title=%ec%a2%8b%ec%9d%80%20%ec%bd%94%eb%93%9c%ec%99%80%20%eb%82%98%ec%81%9c%20%ec%bd%94%eb%93%9c&summary=%ec%a2%8b%ec%9d%80%20%ec%bd%94%eb%93%9c%ec%99%80%20%eb%82%98%ec%81%9c%20%ec%bd%94%eb%93%9c&source=https%3a%2f%2fheozeop.github.io%2fpost%2fbook-good-code-bad-code%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 코드와 나쁜 코드 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fheozeop.github.io%2fpost%2fbook-good-code-bad-code%2f&title=%ec%a2%8b%ec%9d%80%20%ec%bd%94%eb%93%9c%ec%99%80%20%eb%82%98%ec%81%9c%20%ec%bd%94%eb%93%9c"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 코드와 나쁜 코드 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fheozeop.github.io%2fpost%2fbook-good-code-bad-code%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 코드와 나쁜 코드 on whatsapp" href="https://api.whatsapp.com/send?text=%ec%a2%8b%ec%9d%80%20%ec%bd%94%eb%93%9c%ec%99%80%20%eb%82%98%ec%81%9c%20%ec%bd%94%eb%93%9c%20-%20https%3a%2f%2fheozeop.github.io%2fpost%2fbook-good-code-bad-code%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 좋은 코드와 나쁜 코드 on telegram" href="https://telegram.me/share/url?text=%ec%a2%8b%ec%9d%80%20%ec%bd%94%eb%93%9c%ec%99%80%20%eb%82%98%ec%81%9c%20%ec%bd%94%eb%93%9c&url=https%3a%2f%2fheozeop.github.io%2fpost%2fbook-good-code-bad-code%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=heozeop/heozeop.github.io issue-term=title label=Comment theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://heozeop.github.io/>Crispy bLog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>