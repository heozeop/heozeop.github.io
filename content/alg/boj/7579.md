---
title: 앱
date: '2021-08-08'
description: 'ㅠㅠ'
type: 'dp, knapsack'
---

# 문제

> [7579 앱](https://www.acmicpc.net/problem/7579)

## 문제 요약

- 1 ~ 100개 사이의 앱 중 일부를 꺼, 새로운 앱을 킬 M 이상의 메모리공간을 확보하고자 한다.

- 위 조건의 만족을 위해 종료한 앱을 다시 실행하는데 드는 비용의 합을 C라고 하자.

- 이때, C값의 합 중 최솟값을 구하라.

## 내 풀이

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int MAX = 101;
const int MAX_COBINATION = 10001;

int n, m, sumOfCost;
int memory[MAX];
int cost[MAX];
int dp[MAX_COBINATION];

int initiateVariables(int* container, int maximum){
  int sum = 0;
  for(int i = 0; i < maximum; ++i) {
    cin >> container[i];
    sum += container[i];
  }
  return sum;
}

void setDP() {
  for(int i = 0 ; i < n; ++i) {
    for(int j = sumOfCost; j >= cost[i]; --j) {
      dp[j] = max(dp[j - cost[i]] + memory[i], dp[j]);
    }
  }
}

void printMinCost() {
  int i = 0;
  while(dp[i] < m) {
    ++i;
  }
  cout << i << endl;
}

int main(void) {
  cin >> n >> m;

  initiateVariables(memory, n);
  sumOfCost = initiateVariables(cost, n); // ㅎㅎ
  setDP();
  printMinCost();
}
```

# 나의 접근법

### 직접 해보자.

1. 전체 메모리의 합은 주어진 M보다 클 것이다.
1. 전체 메모리에서 하나씩 빼보는 방식으로 해보자.
1. 직접 해보니 O(n!)이 걸리는 것으로 계산하였다.

- 메모리의 합이 M이상이라는 조건으로 C의 최소값을 찾아갔다.

- 20분간 헤메길래 검색했다.

### 점화식

> [나다움님 블로그, 7579 앱](https://life-with-coding.tistory.com/316)

- C의 값이 j일때, i 번째 앱의 종료 여부에 따라 확보한 메모리의 최댓값은 아래 점화식을 만족한다.

  ```c++
    dp[j] = std::max(
      dp[j - cost[i]] + memory[i] // i 번째 포함
      , dp[j] // i 번째 불포함
    )
  ```

- 위 점화식에 따라 dp를 작은 index부터 돌며, M보다 같거나 큰 값이 있는 데이터를 리턴하면 된다.

### 차이에 대한 고찰

1. 전체 합에 대한 집착을 했다.

    최대 합에서 하나씩 빼가면서 구하려면 말그대로 하나씩 빼보는 수밖에 없다. 그렇게 빼보면 위 계산처럼 O(n!)번의 계산이 필요함을 알 수 있다.

    계산이 맞음에도 불구하고, '그러면 어떻게 하지'라는 생각이 지배적이었던 것 같다. 다음에는 반대로 접근해 보는 방식을 시도해 봐야겠다.    